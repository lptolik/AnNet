---
title: "Barabasi's Diseasome analysis"
author: "Anatoly Sorokin, Colin McLean, Oksana Sorokina"
date: '`r format(Sys.time(), "%d.%m.%Y")`'
output:
  pdf_document:
    keep_tex: yes
    number_sections: yes
  html_document: default
  always_allow_html: true
params:
  format: !r if(opts_knit$get("rmarkdown.pandoc.to") == 'html') c('screen', 'print')
    else 'print'
  version: !r if(nchar(Sys.which("git"))) system("git describe --long --dirty --abbrev=10  --tags  --always",
    intern=TRUE) else date()
header-includes:
- \usepackage[utf8]{inputenc}
- \usepackage{grffile}
- \usepackage{rotating}
- \usepackage{caption}
- \usepackage{longtable}
- \usepackage{lscape}
---
```{r loadPackages, include=FALSE, cache=FALSE}
## load additional packages in this chunk
library(pander)
library(knitr)
library(igraph)
library(ggplot2)
library(xtable)
library(AnNet)
library(BiRewire)
```

```{r setup, include=FALSE, cache=FALSE}
## This chunk should contain global configuration commands.
## Use this to set knitr options and related things. Everything
## in this chunk will be included in an appendix to document the
## configuration used.
#output <- opts_knit$get("rmarkdown.pandoc.to")
opts_knit$set(stop_on_error = 2L)


## Cache options
opts_chunk$set(cache=TRUE)


## Set 'hide.fig.code' to FALSE to include code chunks that
## produce Figures in the output. Note that this affects all chunks
## that provide a figure caption.
opts_chunk$set(hold=TRUE, hide.fig.code=FALSE)

## Pander options
panderOptions("digits", 3)
panderOptions("table.split.table", 160)

```

```{r functions, include=FALSE}
## Custom functions used in the analysis should go into this chunk.
## They will be listed in their own section of the appendix.

###### XTable print function for multipage tables in both landscape and portrate
# orientations.
printTable <-
  function(mat,main,landscape = FALSE,digits = 3,sig = 0.01,align= aligShapley) {
    addtorow          <- list()
    addtorow$pos      <- list()
    addtorow$pos[[1]] <- c(0)
    addtorow$command  <- c(
      paste(
        "\\hline \n",
        "\\endhead \n",
        "\\hline \n",
        "\\multicolumn{3}{l}{\\footnotesize Continued on next page} \n",
        "\\endfoot \n",
        "\\endlastfoot \n",sep = ""
      )
    )
    if (landscape) {
      cat(
        sprintf(
          "\\newpage\n  \\begin{landscape} \n\\begin{center}\n\\captionof{table}{%s (%d)}\n\\scriptsize",
          main,dim(mat)[1]
        )
      )
    }else{
      cat(
        sprintf(
          "\\begin{center}\n\\captionof{table}{%s (%d)}\n\\scriptsize",
          main,dim(mat)[1]
        )
      )
    }
    #alig <- c('p{0.15\\linewidth}','|p{0.15\\linewidth}|','p{0.60\\linewidth}|','p{0.15\\linewidth}|')
    alig <- align
    cat(dim(mat),names(mat),'\n')
    matU<-mat
    # matU$name<-sanitizestr(mat$name)
    # matU$description<-sanitizestr(mat$description)
    # cat(dim(matU),names(matU),'\n')
    print(
      xtable(
        matU,
        align = alig,#paste(align,collapse = ''),
        digits = digits)
      ,size = "small",include.colnames = TRUE,
      tabular.environment = "longtable", #sanitize.text.function=function(.x)sanitizestr(stri_escape_unicode(.x)),
      floating = FALSE,include.rownames = FALSE,add.to.row = addtorow,hline.after =
        c(-1)
    )
    if (landscape) {
      cat("\\end{center}\n \\end{landscape}")
    }else{
      cat("\\end{center}\n ")
    }
    
  }
getCSizes<-function(g,src='diseasome'){
  c<-components(g)
  csz.df<-data.frame(i=1:c$no,csize=c$csize,src=src)
  return(csz.df)
}
```

# Read data
```{r create.bipartite.graph}
vdf<-read.csv('pnas.0701361104/node_list.csv')
edf<-read.csv('pnas.0701361104/edge_list.csv')
vdf$label<-vdf$Name
vdf$shape<-ifelse(vdf$Type=='Disease','circle','square')
vdf$type<-vdf$Type=='Gene'
diseasome<-igraph::graph_from_data_frame(edf,directed = FALSE,vertices = vdf)
saveRDS(diseasome,file = 'diseasome.rds')
is_bipartite(diseasome)
```

# Make random graph rewiring
Igraph has functions `rewire` and `keeping_degseq` to generate random graphs by swaping
ends between stochastically picked edges. However, application of such algorithm
to bipartite graph, like our diseasome, would create edges between nodes of the
same type and break definition of bipartite graph. To avoid this we will use 
`BiRewire` package for generation of the set of random graphs:
```{r rewire.bipartite.graph}
lr.diseasome<-lapply(1:10000,birewire.rewire.bipartite,
                     incidence=diseasome,verbose=FALSE,exact=TRUE)
saveRDS(lr.diseasome,file = 'lr.diseasome.rds')
```

```{r diseasome.components}
csz.df<-getCSizes(diseasome)
mcsz<-max(csz.df$csize)
lcsz<-lapply(lr.diseasome,getCSizes,src='rewiring')
csz.df<-rbind(csz.df,do.call(rbind,lcsz))
mcomp<-csz.df[(csz.df$csize>100)&(csz.df$src=='rewiring'),]
avgMaxSize<-mean(mcomp$csize)
sdMaxSize<-sd(mcomp$csize)
pVal<-length(which(mcomp$csize<=mcsz))/(dim(mcomp)[1])
```

```{r plot.diseasome.components.distr,fig.width=12,fig.height=12,warning=FALSE}
qplot(csize,data=csz.df,fill=src,bins=200,log = 'xy')+
  geom_vline(xintercept = mcsz)+ 
  labs(x = "Component size",
       title='Diseasome component size distribution',
       fill = 'Type')
```

Vertical line on the graph corresponds to the size of the giant component of the
original diseasome. Like in the original Barabasi paper its size (`r mcsz`) is 
significantly lower (pval=`r pVal`) than the average size of the giant component (`r avgMaxSize` `r sdMaxSize`) in the set of rewired networks.

# Project to HDN and DGN
We can create Human Disease Network (HDN) and Disease Gene Network (DGN) by creation
ofthe two natural projections of the bipartite Diseasome graph: 
```{r project.bipartite.graph}
projList<-bipartite.projection(diseasome)
hdn<-projList[[1]]
dgn<-projList[[2]]
```

And similarily we can create list of random HDN and DGN graphs from the list of 
rewired diseasome graphs:
```{r project.rewired.bipartite.graphs}
lr.proj<-lapply(lr.diseasome,bipartite.projection)
saveRDS(lr.proj,file = 'lr.proj.rds')
lr.hdn<-lapply(lr.proj, function(.x).x[[1]])
lr.dgn<-lapply(lr.proj, function(.x).x[[2]])
rm(lr.proj)
```


# Analyse HDN
```{r prepare.hdn.component.plot}
csz.df<-getCSizes(hdn)
mcsz<-max(csz.df$csize)
lcsz<-lapply(lr.hdn,getCSizes,src='rewiring')
csz.df<-rbind(csz.df,do.call(rbind,lcsz))
mcomp<-csz.df[(csz.df$csize>100)&(csz.df$src=='rewiring'),]
avgMaxSize<-mean(mcomp$csize)
sdMaxSize<-sd(mcomp$csize)
pVal<-length(which(mcomp$csize<=mcsz))/(dim(mcomp)[1])
```

```{r plot.hdn.components.distr,fig.width=12,fig.height=12,warning=FALSE}
qplot(csize,data=csz.df,fill=src,bins=200,log = 'xy')+
  geom_vline(xintercept = mcsz)+ 
  labs(x = "Component size",
       title='HDN component size distribution',
       fill = 'Type')
```

Vertical line on the graph corresponds to the size of the giant component of the
original HDN. Like in the original Barabasi paper its size (`r mcsz`) is 
significantly lower (pval=`r pVal`) than the average size of the giant component (`r avgMaxSize` `r sdMaxSize`) in the set of rewired networks.

# Analyse DGN
```{r prepare.dgn.component.plot}
csz.df<-getCSizes(dgn)
mcsz<-max(csz.df$csize)
lcsz<-lapply(lr.dgn,getCSizes,src='rewiring')
csz.df<-rbind(csz.df,do.call(rbind,lcsz))
mcomp<-csz.df[(csz.df$csize>100)&(csz.df$src=='rewiring'),]
avgMaxSize<-mean(mcomp$csize)
sdMaxSize<-sd(mcomp$csize)
pVal<-length(which(mcomp$csize<=mcsz))/(dim(mcomp)[1])
```

```{r plot.dgn.components.distr,fig.width=12,fig.height=12,warning=FALSE}
qplot(csize,data=csz.df,fill=src,bins=200,log = 'xy')+
  geom_vline(xintercept = mcsz)+ 
  labs(x = "Component size",
       title='DGN component size distribution',
       fill = 'Type')
```

Vertical line on the graph corresponds to the size of the giant component of the
original DGN. Like in the original Barabasi paper its size (`r mcsz`) is 
significantly lower (pval=`r pVal`) than the average size of the giant component (`r avgMaxSize` `r sdMaxSize`) in the set of rewired networks.



\pagebreak
# Appendix {.tabset}
## Functions
```{r functions, eval=FALSE, include=TRUE}
```
```{r queries, eval=FALSE, include=TRUE}
```

## Setup R
```{r setup, eval=FALSE}
```

## Versions
### Document version
```{r docVersion, echo=FALSE, results='asis', cache=FALSE}
cat(params$version)
```

### Session Info
```{r sessionInfo, echo=FALSE, results='asis', class='text', warning=FALSE}
si<-devtools::session_info()
cat('Platform\n\n')
pander::pander(si$platform)
cat('Packages\n\n')
knitr::kable(as.data.frame(si$packages)[,c('ondiskversion','loadedversion','date','source')],align = c('l','l'))
```
