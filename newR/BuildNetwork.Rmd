---
title: "BuildNetwork"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{BuildNetwork}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(AnNet)
library(synaptome.db)
```
# Title   AnNet: library for comprehensive network analysis
##  Authors: Colin Mclean, Anatoly Sorokin, J. Douglas Armstrong and Oksana Sorokina    

#Introduction

# Overview of capabilities
# Build the network

The package allows building the network from the data frame, where the rows correspond to the edges of the graph, or for the list of nodes (genes), for which the information will be retrieved from the SynaptomeDB.

## Build the network from data frame
The command builds the graph from provided data frame, simplifies the graph (removing multiple edges and loops) and finds the MCC (maximum connected component)
```{r network_from_scratch}

file <- system.file("extdata", "PPI_Presynaptic.csv", package = "AnNet")
tbl <- read.csv(file, sep="\t")
head(tbl)
gg <- buildNetwork(tbl)
summary(gg)

```
## Build network for the node list extracted from SynaptomeDB

```{r net_from_SynaptomeDB}

cid<-match('Presynaptic',getCompartments()$Name) # Let's get the ID for presynaptic compartment
cid
t<-getAllGenes4Compartment(cid) # Now we need to collect all the gene IDs for presinaptic  compartment
dim(t)
head(t)
gg<-buildFromSynaptomeByEntrez(t$HumanEntrez) # finally, build the graph using respecctive gene EntrezIDs as node IDs
summary(gg)

```
## Use the predifined network
```{r net_predifind}

file <- system.file("extdata", "PPI_Presynaptic.gml", package = "AnNet")
gg1 <- igraph::read.graph(file,format="gml")
summary(gg1)
```
# Annotate the nodes with node attributes
## Gene name
Adding gene names to nodes.
```{r annotate_net}

agg<-annotateGeneNames(gg)
summary(agg)
head(V(agg))
head(V(agg)$GeneName)
```
## Diseases
Adding diseases associations from HDO database
```{r annotate_topOnto}
afile<-system.file("extdata", "flatfile_human_gene2HDO.csv", package = "AnNet")
dis    <- read.table(afile,sep="\t",skip=1,header=F,strip.white=T,quote="")
ggo <- annotate_topOnto_ovg(agg, dis)
summary(ggo)

```
##Shanno
Adding synaptic function annotated from еру Shanno et al.,paper
```{r annotate_Shanno}
sfile<-system.file("extdata", "SCH_flatfile.csv", package = "AnNet")
shan   <- read.table(sfile,sep="\t",skip=1,header=F,strip.white=T,quote="")
sgg<-annotate_SCHanno(agg,shan)
summary(sgg)
```
## Chua
Adding presynaptic functionality from the annotated Boyken et al paper 
```{r annotate_Chua}
sfile<-system.file("extdata", "flatfile_chua.csv", package = "AnNet")
chua <- read.table(sfile,sep="\t",skip=1,header=F,strip.white=T,quote="")
sgg <- annotate_CHUA(agg, chua)
summary(sgg)
```
## GO
Adding functionality from GO: BP, MF,CC
```{r annotate_go}
sfile<-system.file("extdata", "flatfile.go.BP.csv", package = "AnNet")
goBP <- read.table(sfile,sep="\t",skip=1,header=F,strip.white=T,quote="")
sgg <- annotate_go_bp(agg, goBP)
summary(sgg)

sfile<-system.file("extdata", "flatfile.go.MF.csv", package = "AnNet")
goMF <- read.table(sfile,sep="\t",skip=1,header=F,strip.white=T,quote="")
sgg <- annotate_go_mf(agg, goMF)
summary(sgg)

sfile<-system.file("extdata", "flatfile.go.CC.csv", package = "AnNet")
goCC <- read.table(sfile,sep="\t",skip=1,header=F,strip.white=T,quote="")
sgg <- annotate_go_cc(agg, goCC)
summary(sgg)

```

#Esimate node centrality measures
## Estimate centrality measures with values added as node attributes. 
Centrality measures are as following:DEG - degree, BET - betweenness, CC - clustering coefficient, SL - semilocal centrality, mnSP - mean shortest path, PR - page rank, sdSP - standard deviation of the shortest path

```{r graph_cent}
cgg <- calcCentrality(sgg)
summary(cgg)
```
##Get node centralities as a matrix. 
The same centrality measures as before are presented in a matrix form.
```{r matrix_cent}
mc <- getCentralityMatrix(sgg)
head(mc)
```
##Get the centrality measures for random graph - NOT WORKING
Sometimes one needs to compare the graph properties of the given network with the ones of the randomized graph. Command below provides three ways of randomization, including G(n,p) Erdos-Renyi model , Barabasi-Albert model and new random graph from a given graph by randomly adding/removing edges.

```
{r}
ggrm <- getRandomGraphCentrality(sgg, type = c("cgnp"))
head(ggrm)
```

## Power low fit
```{r powerLow,fig.height=9,fig.width=9}
pFit <- FitDegree( as.vector(igraph::degree(graph=sgg)),plot=TRUE,WIDTH=2480, HEIGHT=2480)
```
## Get modularity. Niormalised modularity -- NOT WORKING
Calculates the normalized network modularity value.
Qm based on the previous studies by Parter et al., 2007, Takemoto, 2012,
Takemoto, 2013, Takemoto and Borjigin, 2011, which was defined as:
Qm = (Qreal-Qrand)/(Qmax-Qrand)
Where Qreal is the network modularity of a real-world signaling network and,
Qrand is the average network modularity value obtained from 10,000
randomized networks constructed from its real-world network. Qmax was
estimated as: 1 − 1/M, where M is the number of modules in the real network.
Randomized networks were generated from a real-world network using the
edge-rewiring algorithm (Maslov and Sneppen, 2002).
```{r norm_mod}
#' cid<-match('Presynaptic',getCompartments()$Name)
#' t<-getAllGenes4Compartment(cid)
#' gg<-buildFromSynaptomeByEntrez(t$HumanEntrez)
nm<-normModularity(gg,alg='louvain')
nm
```
## Get entopy rate
```{r ent_rate}
ent <- getEntropyRate(gg)
ent
SRprime <- getEntropy(gg, maxSr = NULL)
head(SRprime)
plotEntropy(SRprime, subTIT = "Entropy", SRo = ent$SRo, maxSr = ent$maxSr)
```
## Clustering
calcClustering allows to calculate memberships for all clustering algorithms and store them on the graph vertices. The possible algorithms are: lec", "wt", "fc", "infomap", "louvain", "sgG1", "sgG2", "sgG5"
Then, for each algorithm of interest the membership could be obtained with calcMembership command.

```{r cluster}
ggc <- calcClustering(gg)
summary(ggc)

mem <- calcMembership(ggc, alg = c("lec"))# choose one algorithm from the list
head(mem)

```
## Consensus clustering
For assessing the robustness of the clustering randomization study could be performed, which applies the same clustering algorithm to N perturbed networks and returns the consensus matrix where each pair of nodes will be assigned the probability to belong to the same cluster.
```{r cons_mat}

m <- makeConsensusMatrix(gg, N=100,alg = "lec", type = 1,mask = 10,reclust = FALSE, Cnmin = -1, Cnmax = 10)

```

